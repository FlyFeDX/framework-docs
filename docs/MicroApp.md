# 微前端

  <img src="https://flyfedx.github.io/framework-docs/images/framework-base/microapp1.png"  width="520">

## 什么是微前端框架

  <img src="https://flyfedx.github.io/framework-docs/images/framework-base/microapp2.png"  width="520">

### 微前端的价值

- 微前端架构具备以下几个核心价值：
  - 技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权
  - 独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新
  - 独立运行时 每个子应用之间状态隔离，运行时状态不共享

### 微前端是如何加载的

通常前端页面应用打包结果的入口就是一段 `<script>`标签加载 js 文件，执行后往某一个 dom 节点下挂载内容，类似如下：

```html
<html>
  <head>
    ...
  </head>
  <body>
    <div id="root"></div>
    <script src="//cdn/entry/main-app.js@1.0.2"></script>
  </body>
</html>
```

当在页面访问不同路由 (url) 时，原本打包的 js 内部会去异步加载对应路由、组件的 chunk js，拿到代码后再去渲染这个路由下的内容 / 组件；

以 webpack 为例，是通过插入 `<script>` 标签来获取其他 chunk js，每个 chunk js 中通过 jsonp 的方式来加载 (入口文件则是 IIFE)。

```html
<html>
  <head>
    ...
    <script src="//cdn/chunk/0.f3c200e0.async.js"></script>
    <script src="//cdn/chunk/1.5bb06b78.async.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script src="//cdn/entry/main-app.js@1.0.2"></script>
  </body>
</html>
```

```js
// 0.f3c200e0.async.js
(window.webpackJsonp = window.webpackJsonp || []).push([chunkId], xxxChunk)
```

那么换到微前端框架上，这个加载会有一点区别，具体来说，是在渲染某些区域的内容时，从「加载自身 chunk」变成 「加载应用入口」，加载器从 webpack 换成「微前端容器」。

以访问 `https://xxx-domiain/main-app/sub-route/xxxx` 为例，简化流程为：

1. 主应用匹配到 `/main-app/sub-soute` 路由，渲染当前路由内容

2. 当前路由内容中有子应用，则异步加载子应用入口

3. 子应用匹配到 `/sub-route/xxxx` 路由，在自己的区域内渲染对应路由内容

微前端框架实际上就是 「父应用加载子应用入口」，再简单预设这个「入口」也就是一段 js (或 html)

## 微前端架构

中后台应用由于其应用生命周期长(动辄 3+ 年)等特点，最后演变成一个巨石应用的概率往往高于其他类型的 web 应用。而从技术实现角度，微前端架构解决方案大概分为两类场景：

- 单实例：即同一时刻，只有一个子应用被展示，子应用具备一个完整的应用生命周期。通常基于 url 的变化来做子应用的切换。
- 多实例：同一时刻可展示多个子应用。通常使用 Web Components 方案来做子应用封装，子应用更像是一个业务组件而不是应用

MPA 方案的优点在于 部署简单、各应用之间硬隔离，天生具备技术栈无关、独立开发、独立部署的特性。缺点则也很明显，应用之间切换会造成浏览器重刷，由于产品域名之间相互跳转，流程体验上会存在断点。

SPA 则天生具备体验上的优势，应用直接无刷新切换，能极大的保证多产品之间流程操作串联时的流程性。缺点则在于各应用技术栈之间是强耦合的。

目标：将二者优势结合起来，构建出一个相对完善的微前端架构方案

微前端架构的优势，正是 MPA 与 SPA 架构优势的合集。即保证应用具备独立开发权的同时，又有将它们整合到一起保证产品完整的流程体验的能力。

<img src="https://flyfedx.github.io/framework-docs/images/framework-base/microapp3.jpeg"  width="1000">

Stitching layer 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位是：<b>导航路由 + 资源加载框架</b>。

## 为什么我们需要微前端？

1. 系统本身是需要集成和被集成的 一般有两种情况：
    - 旧的系统不能下，新的需求还在来。
      没有一家商业公司会同意工程师以单纯的技术升级的理由，直接下线一个有着一定用户的存量系统的。而你大概又不能简单通过 iframe 这种「靠谱的」手段完成新功能的接入，因为产品说需要「弹个框弹到中间」
    - 你的系统需要有一套支持动态插拔的机制。
      这个机制可以是一套精心设计的插件体系，但一旦出现接入应用或被接入应用年代够久远、改造成本过高的场景，可能后面还是会过渡到各种微前端的玩法。
2. 系统中的部件具备足够清晰的服务边界 
    - 通过微前端手段划分服务边界，将复杂度隔离在不同的系统单元中，从而避免因熵增速度不一致带来的代码腐化的传染，以及研发节奏差异带来的工程协同上的问题。
3. 团队沟通协作成本太高
    - 如移动/联通功能类似但细节不一致
    - 如移动/联通版本版本发布时间不一致
4. <b>微前端是我们针对R版本业务应用接入的接口</b>
